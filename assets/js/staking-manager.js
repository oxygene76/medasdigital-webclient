// ===================================
// STAKING-MANAGER.JS - NUR STAKINGMANAGER!
// ===================================

class StakingManager {
    constructor() {
        this.chainId = "medasdigital-2";
        this.denom = "umedas";
        this.decimals = 6;
        this.gasPrice = 0.025;
    }

    async connectKeplr() {
        try {
            if (!window.keplr) {
                throw new Error('Keplr extension not found. Please install Keplr.');
            }

            await window.keplr.enable(this.chainId);
            const key = await window.keplr.getKey(this.chainId);
            
            console.log('‚úÖ Keplr connected:', key.bech32Address);
            return {
                address: key.bech32Address,
                pubkey: key.pubKey
            };
        } catch (error) {
            console.error('‚ùå Keplr connection failed:', error);
            throw error;
        }
    }

    async getAccountInfo(address) {
        try {
            const restUrl = window.MEDAS_CHAIN_CONFIG?.rest || 'https://lcd.medas-digital.io:1317';
            const response = await fetch(`${restUrl}/cosmos/auth/v1beta1/accounts/${address}`);
            
            if (!response.ok) {
                throw new Error(`Account info fetch failed: ${response.status}`);
            }

            const data = await response.json();
            return {
                accountNumber: data.account.account_number.toString(),
                sequence: data.account.sequence.toString()
            };
        } catch (error) {
            console.error('‚ùå Failed to get account info:', error);
            return {
                accountNumber: "0",
                sequence: "0"
            };
        }
    }

   createDelegateMessage(delegatorAddress, validatorAddress, amount) {
    console.log('üîß Creating delegate message for SDK 0.50.10...');
    console.log('üìä Params:', { delegatorAddress, validatorAddress, amount });
    
    // ‚úÖ COSMOS SDK 0.50.10 MESSAGE FORMAT
    const message = {
        "@type": "/cosmos.staking.v1beta1.MsgDelegate",  // ‚Üê Protobuf type URL!
        delegator_address: delegatorAddress,
        validator_address: validatorAddress,
        amount: {
            denom: this.denom,
            amount: amount.toString()
        }
    };
    
    console.log('‚úÖ Created delegate message:', message);
    return message;
}

createUndelegateMessage(delegatorAddress, validatorAddress, amount) {
    console.log('üîß Creating undelegate message for SDK 0.50.10...');
    
    const message = {
        "@type": "/cosmos.staking.v1beta1.MsgUndelegate",  // ‚Üê Protobuf type URL!
        delegator_address: delegatorAddress,
        validator_address: validatorAddress,
        amount: {
            denom: this.denom,
            amount: amount.toString()
        }
    };
    
    console.log('‚úÖ Created undelegate message:', message);
    return message;
}

createWithdrawRewardsMessage(delegatorAddress, validatorAddress) {
    console.log('üîß Creating withdraw rewards message for SDK 0.50.10...');
    
    const message = {
        "@type": "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",  // ‚Üê Protobuf type URL!
        delegator_address: delegatorAddress,
        validator_address: validatorAddress
    };
    
    console.log('‚úÖ Created withdraw rewards message:', message);
    return message;
}

    calculateFee(gasLimit) {
        const gasAmount = Math.ceil(gasLimit * this.gasPrice);
        return {
            gas: gasLimit.toString(),
            amount: [{
                denom: this.denom,
                amount: gasAmount.toString()
            }]
        };
    }

    async signWithAmino(signerAddress, messages, fee, memo = "") {
        try {
            const accountInfo = await this.getAccountInfo(signerAddress);
            
            const signDoc = {
                chain_id: this.chainId,
                account_number: accountInfo.accountNumber,
                sequence: accountInfo.sequence,
                timeout_height: "0",
                fee: fee,
                msgs: messages,
                memo: memo
            };

            console.log('üìù Signing document:', signDoc);

            const signResponse = await window.keplr.signAmino(
                this.chainId,
                signerAddress,
                signDoc,
                {
                    preferNoSetFee: false,
                    preferNoSetMemo: false,
                    disableBalanceCheck: false
                }
            );

            console.log('‚úÖ Amino signing successful');
            return signResponse;
        } catch (error) {
            console.error('‚ùå Amino signing failed:', error);
            throw error;
        }
    }

   // ===================================
// üéØ IHRE BEIDEN FUNKTIONEN - DIREKT UND OHNE FALLBACKS
// ===================================

async encodeTxForBroadcast(signedTx) {
    try {
        console.log('üîç VOLLST√ÑNDIGES ENCODING DEBUG:');
        console.log('================================');
        
        // ‚úÖ SCHRITT 1: SignedTx komplett analysieren
        console.log('üìä ROHE SignedTx Struktur:');
        console.log('- signedTx:', signedTx);
        console.log('- signedTx.signed:', signedTx.signed);
        console.log('- signedTx.signed.msgs:', signedTx.signed.msgs);
        console.log('- signedTx.signed.msgs.length:', signedTx.signed.msgs?.length);
        
        if (signedTx.signed.msgs && signedTx.signed.msgs.length > 0) {
            signedTx.signed.msgs.forEach((msg, i) => {
                console.log(`- Message ${i}:`, msg);
                console.log(`- Message ${i} keys:`, Object.keys(msg));
                console.log(`- Message ${i} @type:`, msg['@type']);
                console.log(`- Message ${i} type:`, msg.type);
            });
        } else {
            console.error('‚ùå PROBLEM: Keine Messages gefunden!');
        }
        
        // ‚úÖ SCHRITT 2: Amino TX erstellen mit DEBUG
        const aminoTx = {
            msg: signedTx.signed.msgs,
            fee: signedTx.signed.fee,
            signatures: [signedTx.signature],
            memo: signedTx.signed.memo || ""
        };
        
        console.log('üìä AMINO TX STRUKTUR:');
        console.log('- aminoTx:', aminoTx);
        console.log('- aminoTx.msg:', aminoTx.msg);
        console.log('- aminoTx.msg.length:', aminoTx.msg?.length);
        
        // ‚úÖ SCHRITT 3: JSON Serialization mit DEBUG
        const jsonString = JSON.stringify(aminoTx);
        console.log('üìä JSON SERIALIZATION:');
        console.log('- JSON string length:', jsonString.length);
        console.log('- JSON string (first 500 chars):', jsonString.substring(0, 500));
        
        // ‚úÖ SCHRITT 4: Base64 mit DEBUG  
        const base64String = btoa(jsonString);
        console.log('üìä BASE64 ENCODING:');
        console.log('- Base64 length:', base64String.length);
        console.log('- Base64 (first 100 chars):', base64String.substring(0, 100));
        
        // ‚úÖ SCHRITT 5: Validierung
        if (jsonString === '{"msg":[],"fee":{},"signatures":[],"memo":""}') {
            console.error('‚ùå LEER: Transaction ist komplett leer!');
            throw new Error('Transaction is empty - all fields are empty');
        }
        
        if (!aminoTx.msg || aminoTx.msg.length === 0) {
            console.error('‚ùå LEER: Messages Array ist leer!');
            throw new Error('Messages array is empty');
        }
        
        console.log('‚úÖ Encoding validation passed');
        return jsonString;
        
    } catch (error) {
        console.error('‚ùå Encoding failed with full debug:', error);
        throw error;
    }
}

// ===================================
// üéØ PROBLEM GEFUNDEN: RPC Format ist falsch!
// ===================================

// Das Problem: broadcast_tx_sync erwartet RAW PROTOBUF, aber wir senden Amino JSON!
// Die L√∂sung: Verwenden Sie broadcast_tx_async oder anderen Endpoint

// Ersetzen Sie Ihre broadcastTransaction Methode:

async broadcastTransaction(signedTx) {
    try {
        console.log('üì° Broadcasting with corrected RPC format...');
        
        // ‚úÖ SCHRITT 1: Erstelle das KORREKTE Amino Format f√ºr RPC
        const aminoTx = {
            msg: signedTx.signed.msgs,
            fee: signedTx.signed.fee,
            signatures: [signedTx.signature],
            memo: signedTx.signed.memo || ""
        };
        
        console.log('üìä Amino TX for RPC:', aminoTx);
        
        // ‚úÖ METHODE 1: Versuche broadcast_tx_async (nimmt oft JSON)
        try {
            console.log('üì° Trying broadcast_tx_async...');
            
            const asyncResponse = await fetch('https://rpc.medas-digital.io:26657/broadcast_tx_async', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    jsonrpc: "2.0",
                    id: 1,
                    method: "broadcast_tx_async",
                    params: {
                        tx: btoa(JSON.stringify(aminoTx))
                    }
                })
            });
            
            if (asyncResponse.ok) {
                const asyncResult = await asyncResponse.json();
                console.log('üì° broadcast_tx_async result:', asyncResult);
                
                if (!asyncResult.error && asyncResult.result) {
                    console.log('‚úÖ broadcast_tx_async successful!');
                    return {
                        success: true,
                        txHash: asyncResult.result.hash,
                        code: 0,
                        rawLog: 'Transaction submitted async',
                        endpoint: 'broadcast_tx_async'
                    };
                }
            }
        } catch (asyncError) {
            console.log('‚ö†Ô∏è broadcast_tx_async failed:', asyncError.message);
        }
        
        // ‚úÖ METHODE 2: Versuche broadcast_tx_commit (vollst√§ndige Verarbeitung)
        try {
            console.log('üì° Trying broadcast_tx_commit...');
            
            const commitResponse = await fetch('https://rpc.medas-digital.io:26657/broadcast_tx_commit', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    jsonrpc: "2.0",
                    id: 1,
                    method: "broadcast_tx_commit",
                    params: {
                        tx: btoa(JSON.stringify(aminoTx))
                    }
                })
            });
            
            if (commitResponse.ok) {
                const commitResult = await commitResponse.json();
                console.log('üì° broadcast_tx_commit result:', commitResult);
                
                if (!commitResult.error && commitResult.result) {
                    const deliverTx = commitResult.result.deliver_tx;
                    
                    if (deliverTx && deliverTx.code === 0) {
                        console.log('‚úÖ broadcast_tx_commit successful!');
                        return {
                            success: true,
                            txHash: commitResult.result.hash,
                            code: deliverTx.code,
                            rawLog: deliverTx.log || 'Transaction committed',
                            height: commitResult.result.height,
                            endpoint: 'broadcast_tx_commit'
                        };
                    } else {
                        throw new Error(`Transaction failed: ${deliverTx?.log || 'Unknown error'}`);
                    }
                }
            }
        } catch (commitError) {
            console.log('‚ö†Ô∏è broadcast_tx_commit failed:', commitError.message);
        }
        
        // ‚úÖ METHODE 3: Fallback zu LCD /txs (Legacy aber zuverl√§ssig)
        try {
            console.log('üì° Trying legacy LCD /txs...');
            
            const lcdResponse = await fetch('https://lcd.medas-digital.io:1317/txs', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(aminoTx)
            });
            
            if (lcdResponse.ok) {
                const lcdResult = await lcdResponse.json();
                console.log('üì° LCD /txs result:', lcdResult);
                
                if (lcdResult.code === 0) {
                    console.log('‚úÖ LCD /txs successful!');
                    return {
                        success: true,
                        txHash: lcdResult.txhash,
                        code: lcdResult.code,
                        rawLog: lcdResult.raw_log,
                        height: lcdResult.height,
                        endpoint: 'lcd-legacy'
                    };
                } else {
                    throw new Error(`Transaction failed: ${lcdResult.raw_log}`);
                }
            }
        } catch (lcdError) {
            console.log('‚ö†Ô∏è LCD /txs failed:', lcdError.message);
        }
        
        // ‚úÖ METHODE 4: Experimentell - Versuche JSON direkt an RPC
        try {
            console.log('üì° Trying direct JSON to broadcast_tx_sync...');
            
            const directResponse = await fetch('https://rpc.medas-digital.io:26657/broadcast_tx_sync', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    jsonrpc: "2.0",
                    id: 1,
                    method: "broadcast_tx_sync",
                    params: {
                        tx: JSON.stringify(aminoTx)  // ‚Üê JSON direkt, nicht Base64!
                    }
                })
            });
            
            if (directResponse.ok) {
                const directResult = await directResponse.json();
                console.log('üì° Direct JSON result:', directResult);
                
                if (!directResult.error && directResult.result && directResult.result.code === 0) {
                    console.log('‚úÖ Direct JSON successful!');
                    return {
                        success: true,
                        txHash: directResult.result.hash,
                        code: directResult.result.code,
                        rawLog: directResult.result.log || 'Transaction successful',
                        endpoint: 'direct-json'
                    };
                }
            }
        } catch (directError) {
            console.log('‚ö†Ô∏è Direct JSON failed:', directError.message);
        }
        
        throw new Error('All broadcast methods failed - RPC format incompatibility');

    } catch (error) {
        console.error('‚ùå All broadcast attempts failed:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

// ===================================
// üìù WAS PASSIERT:
// ===================================

/*
üéØ DIREKTE STRATEGIE:
1. encodeTxForBroadcast ‚Üí TxEncodeAmino f√ºr echte Protobuf bytes
2. broadcastTransaction ‚Üí Moderne /cosmos/tx/v1beta1/txs API

‚ú® SAUBER UND DIREKT - genau wie Sie es wollten!
*/
    async delegate(delegatorAddress, validatorAddress, amountInMedas) {
        try {
            console.log('ü•© Starting delegation process...');
            
            const account = await this.connectKeplr();
            if (account.address !== delegatorAddress) {
                throw new Error('Connected account does not match delegator address');
            }

            const amountInUmedas = Math.floor(parseFloat(amountInMedas) * Math.pow(10, this.decimals));
            console.log(`Amount in umedas: ${amountInUmedas}`);

            const delegateMsg = this.createDelegateMessage(
                delegatorAddress,
                validatorAddress,
                amountInUmedas
            );

            const gasLimit = 300000;
            const fee = this.calculateFee(gasLimit);

            console.log('üí∞ Transaction fee:', fee);

            const signedTx = await this.signWithAmino(
                delegatorAddress,
                [delegateMsg],
                fee,
                `Stake ${amountInMedas} MEDAS to validator`
            );

            const result = await this.broadcastTransaction(signedTx);

            if (result.success) {
                console.log('üéâ Delegation successful!');
                return {
                    success: true,
                    txHash: result.txHash,
                    message: `Successfully delegated ${amountInMedas} MEDAS`
                };
            } else {
                throw new Error(result.error);
            }
        } catch (error) {
            console.error('‚ùå Delegation failed:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }

    async undelegate(delegatorAddress, validatorAddress, amountInMedas) {
        try {
            console.log('üìâ Starting undelegation process...');

            const account = await this.connectKeplr();
            const amountInUmedas = Math.floor(parseFloat(amountInMedas) * Math.pow(10, this.decimals));

            const undelegateMsg = this.createUndelegateMessage(
                delegatorAddress,
                validatorAddress,
                amountInUmedas
            );

            const gasLimit = 350000;
            const fee = this.calculateFee(gasLimit);

            const signedTx = await this.signWithAmino(
                delegatorAddress,
                [undelegateMsg],
                fee,
                `Unstake ${amountInMedas} MEDAS from validator`
            );

            const result = await this.broadcastTransaction(signedTx);

            if (result.success) {
                console.log('‚úÖ Undelegation successful!');
                return {
                    success: true,
                    txHash: result.txHash,
                    message: `Successfully undelegated ${amountInMedas} MEDAS (21-day unbonding period)`
                };
            } else {
                throw new Error(result.error);
            }
        } catch (error) {
            console.error('‚ùå Undelegation failed:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }

    async claimRewards(delegatorAddress, validatorAddresses) {
        try {
            console.log('üèÜ Starting rewards claiming process...');

            const account = await this.connectKeplr();

            const withdrawMsgs = validatorAddresses.map(validatorAddress =>
                this.createWithdrawRewardsMessage(delegatorAddress, validatorAddress)
            );

            const gasLimit = 200000 + (validatorAddresses.length * 100000);
            const fee = this.calculateFee(gasLimit);

            const signedTx = await this.signWithAmino(
                delegatorAddress,
                withdrawMsgs,
                fee,
                `Claim rewards from ${validatorAddresses.length} validators`
            );

            const result = await this.broadcastTransaction(signedTx);

            if (result.success) {
                console.log('üéâ Rewards claiming successful!');
                return {
                    success: true,
                    txHash: result.txHash,
                    message: `Successfully claimed rewards from ${validatorAddresses.length} validators`
                };
            } else {
                throw new Error(result.error);
            }
        } catch (error) {
            console.error('‚ùå Rewards claiming failed:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }

    formatMedas(amountInUmedas) {
        return (parseInt(amountInUmedas) / Math.pow(10, this.decimals)).toFixed(6);
    }

    formatUmedas(amountInMedas) {
        return Math.floor(parseFloat(amountInMedas) * Math.pow(10, this.decimals));
    }
}

// ===================================
// TESTING FUNKTION
// ===================================
window.testStakingManager = async function() {
    console.log('üß™ TESTING STAKING MANAGER...');
    
    const stakingManager = new StakingManager();
    
    try {
        // Test connection
        const account = await stakingManager.connectKeplr();
        console.log('‚úÖ Keplr connected:', account.address);
        
        // Test account info
        const accountInfo = await stakingManager.getAccountInfo(account.address);
        console.log('‚úÖ Account info:', accountInfo);
        
        // Test message creation
        const testMsg = stakingManager.createDelegateMessage(
            account.address,
            'medasvaloperTest',
            1000000 // 1 MEDAS in umedas
        );
        console.log('‚úÖ Message created:', testMsg);
        
        // Test fee calculation
        const testFee = stakingManager.calculateFee(300000);
        console.log('‚úÖ Fee calculated:', testFee);
        
        return 'StakingManager test complete - all functions working!';
        
    } catch (error) {
        console.error('‚ùå StakingManager test failed:', error);
        return `Test failed: ${error.message}`;
    }
};

// Export
if (typeof module !== 'undefined' && module.exports) {
    module.exports = StakingManager;
} else {
    window.StakingManager = StakingManager;
    console.log('ü•© StakingManager loaded - Cosmos SDK 0.50.10 + Keplr compatible');
}
